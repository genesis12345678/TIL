# 인덱스에 대해서 설명해 주세요.

- **인덱스(`Index`)** 는 데이터베이스의 테이블에 대한 검색 속도를 향상시켜주는 자료구조이다.
- 테이블의 특정 컬럼에 인덱스를 생성하면, 해당 컬럼의 데이터를 정렬한 후 별도의 메모리 공간에 데이터의 물리적 주소와 함께 저장된다.
- 컬럼의 값과 물리적 주소를 `(Key, Value)` 의 한 쌍으로 저장한다.

**클러스터형 인덱스**
- 영어사전처럼 이미 정렬되어 있는 인덱스
- 기본 키로 지정하면 클러스터형 인덱스가 생성되고 해당 열로 자동 정렬된다.

**보조 인덱스**
- 일반 책의 찾아보기와 같이 별도의 공간에 인덱스가 생성된다.
- 고유 키로 지정하면 보조 인덱스가 생성되고 자동 정렬되지 않는다.

**고유 인덱스**
- 값이 중복되지 않는 인덱스
- 기본 키나 고유 키로 지정하면 값이 중복되지 않으므로 고유 인덱스가 자동 생성된다.

|         | 클러스터형 인덱스         | 보조 인덱스          |
|---------|-------------------|-----------------|
| 영문      | Clustered Index   | Secondary Index |
| 관련 제약조건 | 기본 키(`Primary Key`) | 고유 키(`Unique`)    |
| 테이블당 개수 | 1개                | 여러 개            |
| 정렬      | 지정한 열로 정렬됨        | 정렬되지 않음         |

**인덱스 장점**
- `SELECT` 문으로 검색하는 속도가 매우 빨라진다.
- 컴퓨터의 부담이 줄어들어 결국 전체 시스템의 성능이 향상된다.

**인덱스 단점**
- 인덱스도 공간을 차지해서 데이터베이스 안에 추가적인 공간이 필요하다.
  - 대략 테이블 크기의 10% 정도
- 처음에 인덱스를 만드는 데 시간이 오래 걸릴 수 있다.
- `SELECT`가 아닌 데이터의 변경 작업(`INSERT`, `UPDATE`, `DELETE`)이 자주 일어나면 오히려 성능이 나빠질 수 있다.

**인덱스를 사용하면 좋은 경우**
- 규모가 작지 않은 테이블
- `INSERT`, `UPDATE`, `DELETE`가 자주 발생하지 않는 컬럼(데이터의 변경)
- `JOIN`이나 `WHERE` 또는 `ORDER BY`에 자주 사용되는 컬럼
- 데이터의 중복도가 낮은 컬럼


## 인덱스를 효과적으로 사용하는 방법

### WHERE 절에서 사용되는 열에 인덱스를 만들어야 한다.
- `SELECT` 문을 사용할 때, `WHERE` 절의 조건에 해당 열이 나와야 인덱스를 사용한다.
- `WHERE` 절 조건에 나오는 열 외에 인덱스를 만드는 것은 낭비가 된다.

### WHERE 절에 사용되더라도 자주 사용해야 가치가 있다.
- 인덱스는 `SELECT` 문의 성능은 좋아지지만, 데이터의 변경이 일어나는 작업은 오히려 성능이 나빠질 수 있다.
- `SELECT` 문이 자주 사용되지 않는다면 차라리 한 번 조회할 때 인덱스 없이 조회하는 방법이 더 낫다.

### 데이터의 중복이 높은 열은 인덱스를 만들어도 별 효과가 없다.
- 열에 들어갈 데이터의 종류가 몇 가지 안 되면 인덱스가 큰 효과를 내지 못한다.
- 성별, 교통 수단 등 종류가 제한된 것에는 인덱스를 만들어도 효과가 없다.

### 클러스터형 인덱스는 테이블당 하나만 생성할 수 있다.
- 클러스터형 인덱스는 데이터 페이지를 읽는 수가 보조 인덱스보다 적기 때문에 성능이 더 우수하다.
- 그러므로 하나밖에 지정하지 못하는 클러스터형 인덱스(기본 키)는 조회할 때 가장 많이 사용되는 열에 지정하는 것이 효과적이다.

### 사용하지 않는 인덱스는 제거한다.
- 사용되는 SQL을 분석해서 `WHERE` 조건에서 사용되지 않는 열의 인덱스는 제거할 필요가 있다.
- 그러면 공간을 확보할 뿐 아니라, 데이터 입력 시 발생되는 부하도 많이 줄일 수 있다.

<br>

# 인덱스의 알고리즘에는 어떤 것들이 있나요?

- 인덱스는 여러 자료구조를 이용해서 구현할 수 있는데, 대표적으로 [해시 테이블](https://github.com/genesis12345678/TIL/blob/main/interview/dataStructure/1_10/HashTable.md#%ED%95%B4%EC%8B%9C%ED%85%8C%EC%9D%B4%EB%B8%94hast-table%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4-%EC%A3%BC%EC%84%B8%EC%9A%94)과 [B+Tree](https://github.com/genesis12345678/TIL/blob/main/interview/dataStructure/11_20/B%2BTree.md#b-tree%EA%B0%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EC%A7%80-%EC%84%A4%EB%AA%85%ED%95%B4-%EC%A3%BC%EC%84%B8%EC%9A%94)가 있다.

## 해시 테이블(Hash Table)

- 해시 테이블은 `(Key, Value)`로 데이터를 저장하는 자료구조 중 하나로 빠른 데이터 검색이 필요할 때 유용하다.
- `Key`값을 이용해 대응되는 `Value` 값을 구하는 방식이다.
- 해시충돌이라는 변수가 존재하지만 평균적으로 `O(1)`의 매우 빠른 시간만에 원하는 데이터를 탐색할 수 있는 구조이다.


- 해시 테이블을 이용한다면 인덱스는 `(key, value)` = `(컬럼의 값, 데이터의 위치)`로 구현하는데, 해시 테이블은 실제로 인덱스에서 잘 사용되지 않는다.
- 왜냐하면 해시 테이블은 등호(`=`) 연산에 최적화되어 있기 때문이다.
- 데이터베이스에선 부등호(`< , >`) 연산이 자주 사용되는데, 해시 테이블 내의 데이터들은 정렬되어 있지 않으므로 특정 기준보다 크거나 작은 값을 빠르게 찾을 수가 없다.

## B+ Tree

- **B+ Tree**는 DB의 인덱스를 위해 자식 노드가 2개 이상인 `B-Tree`를 개선시킨 자료구조이다.
- 데이터베이스의 인덱스 컬럼은 부등호를 이용한 순차 검색 연산이 자주 발생될 수 있다.
- 때문에 `B-Tree`의 리프노드들을 연결 리스트로 연결하여 순차검색을 용이하게 하는 등 `B-Tree`를 인덱스에 맞게 최적화 하였다.

<br>

### 참고
- [참고 블로그](https://mangkyu.tistory.com/96)